#!/usr/bin/perl

=pod

=head1 NAME

apt-mirror - apt sources mirroring tool

=head1 SYNOPSIS

apt-mirror [--[no-]progress] [--verbose] [configfile]

=head1 DESCRIPTION

A small and efficient tool that lets you mirror a part of or
the whole Debian GNU/Linux distribution or any other apt sources.

Main features:
 * It uses a config similar to APT's F<sources.list>
 * It's fully pool compliant
 * It supports multithreaded downloading
 * It supports multiple architectures at the same time
 * It can automatically remove unneeded files
 * It works well on an overloaded Internet connection
 * It never produces an inconsistent mirror including while mirroring
 * It works on all POSIX compliant systems with Perl and wget

=head1 COMMENTS

apt-mirror uses F</etc/apt/mirror.list> as a configuration file.
By default it is tuned to official Debian or Ubuntu mirrors. Change
it for your needs.

After you setup the configuration file you may run as root:

    # su - apt-mirror -c apt-mirror

Or uncomment the line in F</etc/cron.d/apt-mirror> to enable daily mirror updates.

=head1 FILES

F</etc/apt/mirror.list>
        Main configuration file

F</etc/cron.d/apt-mirror>
        Cron configuration template

F</var/spool/apt-mirror/mirror>
        Mirror places here

F</var/spool/apt-mirror/skel>
        Place for temporarily downloaded indexes

F</var/spool/apt-mirror/var>
        Log files placed here. URLs and MD5 checksums also here.

=head1 CONFIGURATION EXAMPLES

The mirror.list configuration supports many options, the file is well commented explaining each option.
Here are some sample mirror configuration lines showing the various supported ways:

Normal:
deb http://example.com/debian stable main contrib non-free

Arch Specific: (many other architectures are supported)
deb-powerpc http://example.com/debian stable main contrib non-free

HTTP and FTP Auth or non-standard port:
deb http://user:pass@example.com:8080/debian stable main contrib non-free

HTTPS with sending Basic HTTP authentication information (plaintext username and password) for all requests:
(this was default behaviour of Wget 1.10.2 and prior and is needed for some servers with new version of Wget)
set auth_no_challenge 1
deb https://user:pass@example.com:443/debian stable main contrib non-free

HTTPS without checking certificate:
set no_check_certificate 1
deb https://example.com:443/debian stable main contrib non-free

Source Mirroring:
deb-src http://example.com/debian stable main contrib non-free

=head1 AUTHORS

Dmitry N. Hramtsov E<lt>hdn@nsu.ruE<gt>
Brandon Holtsclaw E<lt>me@brandonholtsclaw.comE<gt>

=cut

use warnings;
use strict;
use File::Copy;
use File::Compare;
use File::Path qw(make_path);
use File::Basename;
use Fcntl qw(:flock);
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);
use Getopt::Long;
use Digest::MD5 qw(md5_hex);
use Digest::SHA qw(sha1_hex sha256_hex);
use File::Slurp;
use feature 'fc';
use File::Path;

my $config_file;

my %config_variables = (
	# PATH configs
    "base_path"            => '/var/spool/apt-mirror',
    "mirror_path"          => '$base_path/mirror',
    "skel_path"            => '$base_path/skel',
    "var_path"             => '$base_path/var',
    "tmp_path"             => '/tmp/apt-mirror-tmp',

	"defaultarch"          => `dpkg --print-architecture 2>/dev/null` || 'amd64',

	# main config
    "nthreads"             => 20,
	"cleanscript"          => '$var_path/clean.sh',
    "_contents"            => 1,
    "_autoclean"           => 1,
    "dry_run"              => 0,

	# URL sanitizen
    "_tilde"               => 0,
    "_plus"                => 0,

	# subroutine execution
	"exec_dep11"           => 0,
    "exec_translation"     => 0,
    "exec_cnf"             => 0,
    "exec_deb_ins"         => 0,
    "exec_deb_iso"         => 0,
    "exec_by_hash"         => 0,
    "exec_clean"           => 0,

	# post/pre mirroring
    "postmirror_script"    => '$var_path/postmirror.sh',
    "run_postmirror"       => 1,
    "premirror_script"     => '$var_path/premirror.sh',
    "run_premirror"        => 1,

	# checksum operations
    "pre_check_sum"        => 1,
    "post_check_sum"       => 1,
    "delete_bad_file"      => 1,

	# WGET configs
	"unlink"               => 0,
    "limit_rate"           => '20m',
    "auth_no_challenge"    => 1,
    "no_check_certificate" => 1,
    "no_verbose"           => 1,
    "use_proxy"            => 0,
    "http_proxy"           => '',
    "https_proxy"          => '',
    "proxy_user"           => '',
    "proxy_password"       => '',
    "user_agent"           => 'Aptly/1.0',
    "timeout"              => 30,
    "ip_v6"                => 0,
    "max_redirect"         => 3,
    "none"                 => '0'
);

my @config_binaries = ();
my @config_sources  = ();
my @config_isos     = ();

my @del_files;
my @index_urls;
my @childrens       = ();
my %skipclean       = ();
my %clean_directory = ();
my $verbose         = 0;
my $progress        = 1;

######################################################################################
## Setting up $config_file variable

$config_file = "/etc/apt/mirror.list";    # Default value
GetOptions('verbose|v+', \$verbose,
           'progress|p!', \$progress,
    ) or die "Usage: apt-mirror [--verbose] [--[no-]progress] [configfile]\n";

if ( $_ = shift )
{
    die("apt-mirror: invalid config file specified") unless -e $_;
    $config_file = $_;
}

chomp $config_variables{"defaultarch"};

######################################################################################
## Common subroutines

sub round_number
{
    my $n = shift;
    my $minus = $n < 0 ? '-' : '';
    $n = abs($n);
    $n = int( ( $n + .05 ) * 10 ) / 10;
    $n .= '.0' unless $n =~ /\./;
    $n .= '0' if substr( $n, ( length($n) - 1 ), 1 ) eq '.';
    chop $n if $n =~ /\.\d\d0$/;
    return "$minus$n";
}

sub format_bytes
{
    my $bytes     = shift;
    my $bytes_out = '0';
    my $size_name = 'bytes';
    my $KiB       = 1024;
    my $MiB       = 1024 * 1024;
    my $GiB       = 1024 * 1024 * 1024;

    if ( $bytes >= $KiB )
    {
        $bytes_out = $bytes / $KiB;
        $size_name = 'KiB';
        if ( $bytes >= $MiB )
        {
            $bytes_out = $bytes / $MiB;
            $size_name = 'MiB';
            if ( $bytes >= $GiB )
            {
                $bytes_out = $bytes / $GiB;
                $size_name = 'GiB';
            }
        }
        $bytes_out = round_number($bytes_out);
    }
    else
    {
        $bytes_out = $bytes;
        $size_name = 'bytes';
    }

    return "$bytes_out $size_name";
}

sub get_variable
{
    my $value = $config_variables{ shift @_ };
    my $count = 16;
    while ( $value =~ s/\$(\w+)/$config_variables{$1}/xg )
    {
        die("apt-mirror: too many substitution while evaluating variable") if ( $count-- ) < 0;
    }
    return $value;
}

sub quoted_path
{
    my $path = shift;
    $path =~ s/'/'\\''/g;
    return "'" . $path . "'";
}

sub lock_aptmirror
{
    open( LOCK_FILE, '>', get_variable("var_path") . "/apt-mirror.lock" );
    my $lock = flock( LOCK_FILE, LOCK_EX | LOCK_NB );
    if ( !$lock )
    {
        #-- die("apt-mirror is already running, exiting");
        my $flags = fcntl( LOCK_FILE, F_GETFL, 0) or die "Cannot set flags for lock file: $!\n";
		    fcntl( LOCK_FILE, F_SETFL, $flags | O_NONBLOCK) or die "Cannot get lock file, apt-mirror is running already: $!\n";
    }
}

sub unlock_aptmirror
{
    close(LOCK_FILE);
    unlink( get_variable("var_path") . "/apt-mirror.lock" );
}

sub download_urls
{
    my $stage = shift;
    my @urls;
    my $i = 0;
    my $pid;
    my $nthreads = get_variable("nthreads");
    my @args     = ();
    local $| = 1;

    @urls = @_;
    $nthreads = @urls if @urls < $nthreads;


    # set auth_no_challenge 1
    if ( get_variable("auth_no_challenge") == 1 )
    {
        push( @args, " --auth-no-challenge" );
    }

    # set no_check_certificate 1
    if ( get_variable("no_check_certificate") == 1 )
    {
        push( @args, " --no-check-certificate" );
    }

    # set unlink 1
    if ( get_variable("unlink") == 1 )
    {
        push( @args, " --unlink" );
    }

    # set tries 3
    if ( get_variable("tries") > 0 )
    {
        # '-t=30', '--tries=3'
        push( @args, " --tries=" . get_variable("tries") );
    }

    # set timeout 30
    if ( get_variable("timeout") > 0 )
    {
        # '-T=30', '--timeout=30', '--read-timeout=30', '--dns-timeout=30', '--connect-timeout=30',
        push( @args, " --timeout=" . get_variable("timeout") );
        push( @args, " --read-timeout=" . get_variable("timeout") );
        push( @args, " --dns-timeout=" . get_variable("timeout") );
        push( @args, " --connect-timeout=" . get_variable("timeout") );
    }

    # set limit_rate 25m
    if ( length( get_variable("limit_rate") ) )
    {
        # '--limit-rate=' . get_variable("limit_rate"),
        push( @args, " --limit-rate=" . get_variable("limit_rate") );
    }

    # set user_agent Aptly/1.0
    if ( length( get_variable("user_agent") ) )
    {
        # '--user-agent=' . get_variable("user_agent"),
        push( @args, " --user-agent=" . get_variable("user_agent") );
    }
    else
    {
        push( @args, " --user-agent=Aptly/1.0" );
    }

    # set cookies_file /tmp/apt-mirror.cookies
    if ( length( get_variable("cookies_file") ) )
    {
        # '--load-cookies=afile --save-cookies=afile --keep-session-cookies'
        push( @args, " --load-cookies=" . get_variable("cookies_file") );
        push( @args, " --save-cookies=" . get_variable("cookies_file") );
        push( @args, " --keep-session-cookies" );
        system('touch ' . get_variable("cookies_file"));
    }
    else {
        # /tmp/apt-mirror.cookies
        push( @args, " --load-cookies=/tmp/apt-mirror.cookies" );
        push( @args, " --save-cookies=/tmp/apt-mirror.cookies" );
        push( @args, " --keep-session-cookies" );
        system('touch /tmp/apt-mirror.cookies');
    }

    # set use_proxy       0
    # set http_proxy      127.0.0.1:3128
    # set proxy_user      user
    # set proxy_password  password
    if ( length( get_variable("use_proxy") ) && ( get_variable("use_proxy") eq 'yes' || get_variable("use_proxy") eq 'on'  || get_variable("use_proxy") eq 'true' || get_variable("use_proxy") eq '1' ) )
    {
        if ( length( get_variable("http_proxy") ) || length( get_variable("https_proxy") ) ) { push( @args, " -e use_proxy=yes" ); }
        if ( length( get_variable("http_proxy") ) ) { push( @args, " -e http_proxy=" . get_variable("http_proxy") ); }
        if ( length( get_variable("https_proxy") ) ) { push( @args, " -e https_proxy=" . get_variable("https_proxy") ); }
        if ( length( get_variable("proxy_user") ) ) { push( @args, " -e proxy_user=" . get_variable("proxy_user") ); }
        if ( length( get_variable("proxy_password") ) ) { push( @args, " -e proxy_password=" . get_variable("proxy_password") ); }
    }
    else
    {
        # --no-proxy
        push( @args, " --no-proxy" );
    }

    if ( get_variable("no_verbose") > 0 )
    {
        push( @args, " --no-verbose" );
    }
    else
    {
        push( @args, " --verbose --progress=dot" );
    }

	# --prefer-family=none/IPv4/IPv6 --inet4-only --inet6-only
    if ( get_variable("ip_v6") > 0 )
    {
        push( @args, " --inet6-only --prefer-family=IPv6" );
    }
    else
    {
        push( @args, " --inet4-only --prefer-family=IPv4" );
    }

    if ( get_variable("max_redirect") > 0 )
    {
        push( @args, " --max-redirect=" . get_variable("max_redirect") );
    }

    #--- default arguments for wget
    #-----------------------------
    # '-v', '-r', '-c', '-N', '-l', 'inf',
    # '--no-cache', '--no-hsts', '--retry-connrefused', '--waitretry=3',
    push( @args, " -b -r -N -l inf" );
    push( @args, " --no-cache --no-hsts --retry-on-host-error" );
    push( @args, " --retry-connrefused --waitretry=3 --retry-on-http-error=503,429" );

	#-- special args for index
	push ( @args, " --no-if-modified-since" )  if ( $stage eq "index" );

	#-- special args for archive
	push ( @args, " -c" )  if ( $stage eq "archive" );


    print "   Downloading " . scalar(@urls) . " $stage files using $nthreads threads...\n";


    while ( scalar @urls )
    {
        my @part = splice( @urls, 0, int( @urls / $nthreads ) );

		# construct url file
        open URLS, ">" . get_variable("var_path") . "/$stage-urls.$i" or die("apt-mirror: can't write to intermediate file ($stage-urls.$i)");
        foreach (@part) { print URLS "$_\n"; }
        close URLS or die("apt-mirror: can't close intermediate file ($stage-urls.$i)");
		print join("\n  ", "Downloading batch $i:", @part), "\n"  if ($verbose >= 2);

		# spawn wget (no fork)
        my @dowget = ('nohup /usr/bin/wget', ' -o ', get_variable("var_path") . "/$stage-log.$i", ' -i ', get_variable("var_path") . "/$stage-urls.$i", @args);
        my $exwget = join(' ', @dowget) . ' >/dev/null 2>&1 &';
        system($exwget);

        $i++;
        $nthreads--;
    }


	# wait for wget child instances to finish
    sleep(5);
    my $nums_now = `ps auxw | grep -v grep | grep wget | grep Aptly | wc -l`;
    $nums_now = int($nums_now);

    if ( $nums_now > 2)
    {
        print "   wget ins= $nums_now";
        while ($nums_now > 1)
        {
            sleep(3);
            my $nums_new = `ps auxw | grep -v grep | grep wget | grep Aptly | wc -l`;
            $nums_new = int($nums_new);

            if ( $nums_new < $nums_now && $nums_new > 0 ) { print " " . $nums_new; }
            else { print "."; }

            $nums_now = $nums_new;
        }
        print "\n";
    }

}

## Parse config

sub parse_config_line
{
    my $pattern_deb_line = qr/^[\t ]*(?<type>deb-src|deb)(?:-(?<arch>[\w\-]+))?[\t ]+(?:\[(?<options>[^\]]+)\][\t ]+)?(?<uri>[^\s]+)[\t ]?(?<components>.*)$/;
    my $line = $_;
    my %config;
    if ( $line =~ $pattern_deb_line ) {
        $config{'type'} = $+{type};
        $config{'arch'} = $+{arch};
        $config{'options'} = $+{options} ? $+{options} : "";
        $config{'uri'} = $+{uri};
        $config{'components'} = $+{components};
        if ( $config{'options'} =~ /arch=((?<arch>[\w\-]+)[,]*)/g ) {
            $config{'arch'} = $+{arch};
        }
        $config{'components'} = [ split /\s+/, $config{'components'} ];
    } elsif ( $line =~ /set[\t ]+(?<key>[^\s]+)[\t ]+(?<value>"[^"]+"|'[^']+'|[^\s]+)/ ) {
        $config{'type'} = 'set';
        $config{'key'} = $+{key};
        $config{'value'} = $+{value};
        $config{'value'} =~ s/^'(.*)'$/$1/;
        $config{'value'} =~ s/^"(.*)"$/$1/;
    } elsif ( $line =~ /(?<type>clean|skip-clean|iso)[\t ]+(?<uri>[^\s]+)/ ) {
        $config{'type'} = $+{type};
        $config{'uri'} = $+{uri};
    }

    return %config;
}

open CONFIG, "<$config_file" or die("apt-mirror: can't open config file ($config_file)");
while (<CONFIG>)
{
    next if /^\s*#/;
    next unless /\S/;
    my $line = $_;
    my %config_line = parse_config_line;

    if ( $config_line{'type'} eq "set" ) {
        $config_variables{ $config_line{'key'} } = $config_line{'value'};
        next;
    } elsif ( $config_line{'type'} eq "deb" ) {
        my $arch = $config_line{'arch'};
        $arch = get_variable("defaultarch") if ! defined $config_line{'arch'};
        push @config_binaries, [ $arch, $config_line{'uri'}, @{$config_line{'components'}} ];
        next;
    } elsif ( $config_line{'type'} eq "deb-src" ) {
        push @config_sources, [ $config_line{'uri'}, @{$config_line{'components'}} ];
        next;
    } elsif ( $config_line{'type'} eq "iso" ) {
        my $link = $config_line{'uri'};
        $link =~ s[/$][];
        $link =~ s[~][%7E]g if get_variable("_tilde");
        $link =~ s[\+][%2B]g if get_variable("_plus");
        push @config_isos, $link;
        $skipclean{ $link } = 1;
        next;
    } elsif ( $config_line{'type'} =~ /(skip-clean|clean)/ ) {
        my $link = $config_line{'uri'};
        $link =~ s[^(\w+)://][];
        $link =~ s[/$][];
        $link =~ s[~][%7E]g if get_variable("_tilde");
        $link =~ s[\+][%2B]g if get_variable("_plus");
        if ( $config_line{'type'} eq "skip-clean" ) {
            $skipclean{ $link } = 1;
        } elsif ( $config_line{'type'} eq "clean" ) {
            $clean_directory{ $link } = 1;
        }
        next;
    }

    die("apt-mirror: invalid line in config file ($.: $line ...)");
}
close CONFIG;

die("Please explicitly specify 'defaultarch' in mirror.list") unless get_variable("defaultarch");


######################################################################################
## execute pre-mirror script


if ( get_variable("run_premirror") )
{
    print "Running the Pre Mirror script ...\n";
    print "(" . get_variable("premirror_script") . ")\n\n";
    if ( -e get_variable("premirror_script") )
	{
		if ( -x get_variable("premirror_script") )
		{
			system(get_variable("premirror_script") .'');
		}
		else
		{
			system('/bin/sh', get_variable("premirror_script"));
		}
		print "\nPre Mirror script has completed. See above output for any possible errors.\n\n";
	}
	else {
		print "--- Pre Mirror script not exists.";
	}
}



######################################################################################
## Create the 3 needed directories if they don't exist yet
my @needed_directories = ( get_variable("mirror_path"), get_variable("skel_path"), get_variable("var_path"), get_variable("tmp_path") );

# fresh skel_path
my $skel_path = get_variable("skel_path");
my $dump = `find -L $skel_path -type f -delete >/dev/null 2>&1 &`;

foreach my $needed_directory (@needed_directories)
{
    unless ( -d $needed_directory )
    {
        make_path($needed_directory) or die("apt-mirror: can't create $needed_directory directory");
    }
}
#
#######################################################################################

lock_aptmirror();

######################################################################################
## Skel download


my %urls_to_download = ();
my %stat_cache = ();

my @release_files = ();
my ( $url, $arch );

my $mirror_path = get_variable("mirror_path");
my $var_path = get_variable("var_path");


sub remove_double_slashes
{
    local $_ = shift;
    while (s[/\./][/]g)                { }
    while (s[(?<!:)//][/]g)            { }
    while (s[(?<!:/)/[^/]+/\.\./][/]g) { }
    s/~/\%7E/g if get_variable("_tilde");
    s/\+/\%2B/g if get_variable("_plus");
    return $_;
}

sub flatten_url
{
	my ( $url ) = @_;
	$url = sanitise_uri($url);
	$url =~ s/\//\-/g;
	$url =~ s/\./\-/g;
	return $url;
}


my $tmp_path = get_variable("tmp_path");

sub get_curl_args
{
	my @args = ();

	push( @args, " -ILks --no-keepalive --retry-connrefused --tcp-fastopen --tcp-nodelay" );
	push( @args, " --cookie-jar /tmp/apt-mirror-curl.cookies" );

	if ( get_variable("tries") > 0 )
	{
		push( @args, " --retry " . get_variable("tries") );
	}

    if ( get_variable("timeout") > 0 )
    {
        push( @args, " --max-time " . get_variable("timeout") );
        push( @args, " --connect-timeout " . get_variable("timeout") );
    }

    if ( length( get_variable("user_agent") ) )
    {
        push( @args, " --user-agent " . get_variable("user_agent") );
    }
    else
    {
        push( @args, " --user-agent Aptly/1.0" );
    }


    if ( length( get_variable("use_proxy") ) && ( get_variable("use_proxy") eq 'yes' || get_variable("use_proxy") eq 'on'  || get_variable("use_proxy") eq 'true' || get_variable("use_proxy") eq '1' ) )
    {
		if ( length( get_variable("http_proxy") ) ) { push( @args, " --proxy " . get_variable("http_proxy") ); }
        if ( length( get_variable("https_proxy") ) ) { push( @args, " --proxy " . get_variable("https_proxy") ); }

        if ( length( get_variable("proxy_user") ) && length( get_variable("proxy_password") ) )
		{
			my $proxy = " --proxy_user ";

			if ( length( get_variable("proxy_user") ) )
			{
				$proxy .= get_variable("proxy_user");
			}

			if ( length( get_variable("proxy_password") ) )
			{
				$proxy .= ":" . get_variable("proxy_password");
			}

			push( @args, $proxy );
			push( @args, " --proxy-insecure" );
			push( @args, " --proxytunnel" );
		}
    }
	else
	{
		push( @args, " --noproxy" );
	}

    if ( get_variable("ip_v6") > 0 )
    {
        push( @args, " --ipv6" );
    }
    else
    {
        push( @args, " --ipv4" );
    }

	return " " . join( "", @args );
}


sub get_content_length_from_uri
{
	my ( $url, $size ) = @_;
	my ( $tmp, $res, $arg, $code, $delta, @parts ) = ();
	$url = remove_double_slashes($url);
	$tmp = "$tmp_path/" . flatten_url($url) . ".tmp";

	# delete temp file if too old
	if (-e $tmp )
	{
		$delta = time() - (stat($tmp))[9];
		unlink( $tmp )  if ( $delta > 86400*2 );
	}

	unless (-e $tmp ) {
		$arg = get_curl_args();
		$res = `curl $arg $url 2>&1 -o $tmp`;
		return -1  unless (-e $tmp);
	}

	# check if multi result from curl
	$res = read_file($tmp);
	$res =~ s/HTTP/\n\nHTTP/g;
	@parts = split /\n\n/, $res;
	@parts = grep { $_ ne '' } @parts;

	if ( @parts > 1 )
	{
		$res = $parts[-1]; #last
		$res =~ s/^\s+|\s+$//g;

		open(my $fh, ">$tmp" );
		print $fh $res;
		close $fh;
	}

	$code = `cat $tmp | head -n1`;

	if ( index($code, 200) != -1 )
	{
		$size = `cat $tmp | grep -i "content\-length" | cut -d' ' -f2`;
		$size = length($size)? int($size) : -1;
	}
	else
	{
		$size = -1;
	}
	# print " code=$code size=$size $url \n";
	# print "." if $progress;

	return $size;
}

sub add_url_to_download
{
	my ( $url, $size ) = @_;
    $url = remove_double_slashes($url);

	# check file size
	$size = defined $size? int($size) : 1;
	$urls_to_download{$url} = $size;

    if ( index($url, "Release") != -1 && index($url, ".gpg" ) < 0) {
        my $apath = $url;
        $apath =~ s/https?\:\/\///g;
        $apath = $mirror_path . "/" . remove_double_slashes($apath);
        push( @release_files, $apath );
        # print "\n$apath";
    }

	return $size;
}

sub add_url_to_download_check
{
	my ( $url, $size ) = @_;
    $url = remove_double_slashes($url);

	# check file size
	$size = defined $size? int($size) : 1;
	$size = get_content_length_from_uri($url) if ( $size < 2);
	if ( $size > 0 )
	{
		add_url_to_download($url, $size);
		print "." if $progress;
	}
	return $size;
}

sub mainsub_process_skel
{
	print "\n\n Prepare indexes files: ["  if $progress;

    foreach (@config_sources)
    {
        my ( $uri, $distribution, @components ) = @{$_};

        if (@components)
        {
            $url = $uri . "/dists/" . $distribution . "/";

            add_url_to_download( $url . "InRelease" );
            add_url_to_download_check( $url . "Release" );
            add_url_to_download( $url . "Release.gpg" );
            foreach (@components)
            {
                add_url_to_download( $url . $_ . "/source/InRelease" );
                add_url_to_download( $url . $_ . "/source/Release" );
                add_url_to_download( $url . $_ . "/source/Sources.gz" );
                add_url_to_download( $url . $_ . "/source/Sources.bz2" );
                add_url_to_download( $url . $_ . "/source/Sources.xz" );
            }
        }
        else
        {
            add_url_to_download( $uri . "/$distribution/InRelease" );
            add_url_to_download_check( $uri . "/$distribution/Release" );
            add_url_to_download( $uri . "/$distribution/Release.gpg" );
            add_url_to_download( $uri . "/$distribution/Sources.gz" );
            add_url_to_download( $uri . "/$distribution/Sources.bz2" );
            add_url_to_download( $uri . "/$distribution/Sources.xz" );
        }
    }

    foreach (@config_binaries)
    {
        my ( $arch, $uri, $distribution, @components ) = @{$_};

        if (@components)
        {
            $url = $uri . "/dists/" . $distribution . "/";

            add_url_to_download( $url . "InRelease" );
            add_url_to_download_check( $url . "Release" );
            add_url_to_download( $url . "Release.gpg" );
            if ( get_variable("_contents") )
            {
                add_url_to_download( $url . "Contents-" . $arch . ".gz" );
                add_url_to_download( $url . "Contents-" . $arch . ".bz2" );
                add_url_to_download( $url . "Contents-" . $arch . ".xz" );
            }
            foreach (@components)
            {
                if ( get_variable("_contents") )
                {
                    add_url_to_download( $url . $_ . "/Contents-" . $arch . ".gz" );
                    add_url_to_download( $url . $_ . "/Contents-" . $arch . ".bz2" );
                    add_url_to_download( $url . $_ . "/Contents-" . $arch . ".xz" );
                }
                add_url_to_download( $url . $_ . "/binary-" . $arch . "/InRelease" );
                add_url_to_download( $url . $_ . "/binary-" . $arch . "/Release" );
                add_url_to_download( $url . $_ . "/binary-" . $arch . "/Packages" );
                add_url_to_download( $url . $_ . "/binary-" . $arch . "/Packages.gz" );
                add_url_to_download( $url . $_ . "/binary-" . $arch . "/Packages.bz2" );
                add_url_to_download( $url . $_ . "/binary-" . $arch . "/Packages.xz" );
                add_url_to_download( $url . $_ . "/i18n/Index" );
                add_url_to_download( $url . $_ . "/cnf/Commands-" . $arch . ".xz" );
            }
        }
        elsif ($distribution)
        {
            add_url_to_download( $uri . "/$distribution/InRelease" );
            add_url_to_download_check( $uri . "/$distribution/Release" );
            add_url_to_download( $uri . "/$distribution/Release.gpg" );
            add_url_to_download( $uri . "/$distribution/Packages" );
            add_url_to_download( $uri . "/$distribution/Packages.gz" );
            add_url_to_download( $uri . "/$distribution/Packages.bz2" );
            add_url_to_download( $uri . "/$distribution/Packages.xz" );
        }
        else
        {
            add_url_to_download( $uri . "/InRelease" );
            add_url_to_download_check( $uri . "/Release" );
            add_url_to_download( $uri . "/Release.gpg" );
            add_url_to_download( $uri . "/Packages" );
            add_url_to_download( $uri . "/Packages.gz" );
            add_url_to_download( $uri . "/Packages.bz2" );
            add_url_to_download( $uri . "/Packages.xz" );
        }
    }

    foreach (@config_isos)
    {
        my $uri = $_;
        chomp $uri;
        # print "\n $uri";
        add_url_to_download_check( $uri . "/SHA256SUMS" );
        add_url_to_download_check( $uri . "/SHA512SUMS" );
        add_url_to_download( $uri . "/SHA256SUMS.sign" );
        add_url_to_download( $uri . "/SHA512SUMS.sign" );
    }

	print "]\n" if $progress;

    chdir get_variable("skel_path") or die("apt-mirror: can't chdir to skel");
    @index_urls = sort keys %urls_to_download;
    download_urls( "index", @index_urls );

    foreach ( keys %urls_to_download )
    {
        s[^(\w+)://][];
        s[~][%7E]g if get_variable("_tilde");
        s[\+][%2B]g if get_variable("_plus");
        $skipclean{$_} = 1;
        $skipclean{$_} = 1 if s[\.gz$][];
        $skipclean{$_} = 1 if s[\.bz2$][];
        $skipclean{$_} = 1 if s[\.xz$][];
    }

	# reset global vars
	%urls_to_download = ();
	%stat_cache = ();
}

mainsub_process_skel();


sub parsing_checksum_result
{
    my $fileres = shift;
    my @bad_files;

    open FH, '<', $fileres or die $!;
    while(<FH>){
        my ($afilename, $aresult) = split /\:/, $_;
        push ( @bad_files, $afilename )  if ( $afilename =~ /\/mirror\//);
        # print "\n $afilename --- $aresult ";
    }
    close(FH);

    unlink( @bad_files )  if ( scalar @bad_files && get_variable("delete_bad_file") > 0 );
    # print "\n" . join("\n", @bad_files) . "\n";
}

sub checking_file_sum
{
    my ( $ajob, $akind, $checksum_file ) = @_;

    $ajob = lc($ajob);
    $akind = lc($akind);

    my $checksum_res = "$var_path/res-$ajob-$akind";
    my $checksum_tmp = "$var_path/tmp-$ajob-$akind";

    my $bin_tool = "";
    $bin_tool = "/usr/bin/md5sum"  if ( $akind eq "md5" );
    $bin_tool = "/usr/bin/shasum -a 1"  if ( $akind eq "sha1" );
    $bin_tool = "/usr/bin/shasum -a 256"  if ( $akind eq "sha256" );

    my $cur_fail = 0;
    my $tot_line = 0;
    my $ajob_str = 0;

    $ajob_str = "Packages* Files"  if ( $ajob eq "packages" );
    $ajob_str = "Pre Mirroring"  if ( $ajob eq "pre" );
    $ajob_str = "Post Mirroring"  if ( $ajob eq "post" );

    print "\n   [$ajob_str] Checksum Type: " . sprintf("%6s", uc($akind))  if $progress;
    if (-e $checksum_file && -s $checksum_file )
    {
        my $grepm = 'grep "\/mirror\/"';
        my $grepv = 'grep -iv "no\ssuch\|properly\|WARNING\|OK\|shasum\|md5sum" | ' . $grepm;

        system ("cat $checksum_file | $grepm | sort -u | sort > $checksum_tmp; cp $checksum_tmp $checksum_file");
        system ("$bin_tool -c $checksum_file 2>&1 | $grepv > $checksum_res");

		# only delete files if not post-mirroring checking
        parsing_checksum_result($checksum_res)  if ($ajob ne "post");

        $tot_line = int(`cat $checksum_file | wc -l`);
        $cur_fail = int(`cat $checksum_res | $grepv | wc -l`);
        print ( " \t--- lines= $tot_line \t")  if $progress;
        print ( $cur_fail > 0? "fails= $cur_fail " : "[ OK ]" )  if $progress;
        print ( " \t$checksum_file")  if (-e $checksum_file && $progress);
    }
    else
    {
        print " \t--- checksum file NOT exists" if (-e $checksum_file && $progress);
        print " \t--- empty checksum file" if (-s $checksum_file && $progress);
    }

    return $cur_fail;
}

my (@lines_md5, @lines_sha1, @lines_sha256) = ();
if ( scalar @release_files )
{
    print "\n\n\n Checksum Checking: Packages* files.. "  if $progress;

    my %lines_md5 = ();
    my %lines_sha1 = ();
    my %lines_sha256 = ();
    my $avalue = "";
    my $cur_num_files = 0;
    my $prev_num_files = 0;

    sub append_file_checksum
    {
        my ( $apart, $aline, $arel ) = @_;

        my @cols = split / /, $aline;
        @cols = grep { $_ ne '' } @cols;
        my ( $asum, $asize, $afile ) = @cols;

        my ($arel_file, $arel_dir, $arel_ext) = fileparse($arel, qr/\.[^.]*/);

        chomp $arel_dir;
        my $afile_path = remove_double_slashes($arel_dir . "/" . $afile);
        return  unless (-e $afile_path );

        $avalue = "$asum  $afile_path";
        if ( $apart eq "md5" ) { $lines_md5{$avalue} = $avalue };
        if ( $apart eq "sha1" ) { $lines_sha1{$avalue} = $avalue };
        if ( $apart eq "sha256" ) { $lines_sha256{$avalue} = $avalue };

        $cur_num_files = scalar %lines_md5 + scalar %lines_sha1 + scalar %lines_sha256;
        if ( $prev_num_files != $cur_num_files )
        {
            $prev_num_files = $cur_num_files;
            print "R"  if (-e $afile_path && $progress );
            print "\n OK=$apart $afile_path "  if (-e $afile_path && $verbose > 2 );
        }
    }

    #--- preparing file checksum
    print "\n   Preparing Packages* files checksum: [" if $progress;
    foreach my $arel (@release_files) {
        next unless (-e $arel );

        unless ( open STREAM, "<$arel" )
        {
            warn( "Failed to open Release file from " . $arel )  if ($verbose > 1);
            return;
        }

        my $cur_part = "";
        my $prev_part = "";

        while ( my $aline = <STREAM> )
        {
            chomp $aline;
            $aline =~ s/^\s+|\s+$//g;

            # MD5Sum:, SHA256:, SHA1:
            if ( $aline eq "MD5Sum:" )
            {
                $prev_part = $cur_part;
                $cur_part = 'md5';
                next;
            }
            elsif ( $aline eq "SHA256:" )
            {
                $prev_part = $cur_part;
                $cur_part = 'sha256';
                next;
            }
            elsif ( $aline eq "SHA1:" )
            {
                $prev_part = $cur_part;
                $cur_part = 'sha1';
                next;
            }
            elsif ( index($aline, 'PGP SIGNATURE') != -1 ) {
                $prev_part = $cur_part;
                $cur_part = "";
            }

            if ( $cur_part ne $prev_part )
            {
                # print "\n cur=$cur_part prev=$prev_part"  if $progress;
            }

            #-- skip for short line
            next if ( length($aline) < 10 );

            #-- skip if not Packages.* files
            next if ( index($aline, 'Packages') < 0 );

            append_file_checksum($cur_part, $aline, $arel)  if ( $cur_part eq "md5" );
            append_file_checksum($cur_part, $aline, $arel)  if ( $cur_part eq "sha256" );
            append_file_checksum($cur_part, $aline, $arel)  if ( $cur_part eq "sha1" );

            $prev_part = $cur_part;
        }

        close STREAM;
    }

    # writing to files
    my $input_file_md5 = "$var_path/packages.md5";
    my $input_file_sha1 = "$var_path/packages.sha1";
    my $input_file_sha256 = "$var_path/packages.sha256";

    open FILE_SUM_MD5, ">$input_file_md5" or die("apt-mirror: can't write to intermediate file (MD5) \n[$input_file_md5]");
    open FILE_SUM_SHA1, ">$input_file_sha1" or die("apt-mirror: can't write to intermediate file (SHA1) \n[$input_file_sha1]");
    open FILE_SUM_SHA256, ">$input_file_sha256" or die("apt-mirror: can't write to intermediate file (SHA256) \n[$input_file_sha256]");

    my @keys_md5 = sort keys %lines_md5;
    my @keys_sha1 = sort keys %lines_sha1;
    my @keys_sha256 = sort keys %lines_sha256;
    print FILE_SUM_MD5 join("\n", @keys_md5);
    print FILE_SUM_SHA1 join("\n", @keys_sha1);
    print FILE_SUM_SHA256 join("\n", @keys_sha256);

    close FILE_SUM_MD5;
    close FILE_SUM_SHA1;
    close FILE_SUM_SHA256;
    my $num_file_to_check = scalar @keys_md5 + scalar @keys_sha1 + scalar @keys_sha256;
    print "] {$num_file_to_check lines}. "  if $progress;

    #--- do check
    my $checksum_fails = 0;
    $checksum_fails += checking_file_sum("packages", "md5", $input_file_md5);
    $checksum_fails += checking_file_sum("packages", "sha1", $input_file_sha1);
    $checksum_fails += checking_file_sum("packages", "sha256", $input_file_sha256);
	print "\n\n"  if $progress;

    #--- re-download skel, if fails
    if ( $checksum_fails > 0 )
    {
        print "\n\n --- Redownloading index files: \n"  if $progress;
        mainsub_process_skel();
    }
}



######################################################################################
## Translation index download


# %urls_to_download = ();

sub sanitise_uri
{
    my $uri = shift;
    $uri =~ s[^(\w+)://][];
    #$uri =~ s/^([^@]+)?@?// if $uri =~ /@/;
    $uri =~ s/^([^@]+)?@?// if (split '/',$uri)[0] =~ /@/;
		$uri =~ s&:\d+/$&/&;   # and port information
    $uri =~ s/~/\%7E/g if get_variable("_tilde");
    $uri =~ s/\+/\%2B/g if get_variable("_plus");
    return $uri;
}

sub find_translation_files_in_release
{
    # Look in the dists/$DIST/Release file for the translation files that belong
    # to the given component.

    my $dist_uri  = shift;
    my $component = shift;
    my ( $release_uri, $release_path, $line ) = '';

    $release_uri  = $dist_uri . "Release";
    $release_path = get_variable("skel_path") . "/" . sanitise_uri($release_uri);

    unless ( open STREAM, "<$release_path" )
    {
        warn( "Failed to open Release file from " . $release_uri )  if ($verbose > 1);
        return;
    }

    my $checksums = 0;
    while ( $line = <STREAM> )
    {
        chomp $line;
        if ($checksums)
        {
            if ( $line =~ /^ +(.*)$/ )
            {
                my @parts = split( / +/, $1 );
                if ( @parts == 3 )
                {
                    my ( $sha1, $size, $filename ) = @parts;
                    if ( $filename =~ m{^$component/i18n/Translation-[^./]*\.(bz2|xz|gz)$} )
                    {
                        add_url_to_download( $dist_uri . $filename, $size );
                    }
                }
                else
                {
                    warn("Malformed checksum line \"$1\" in $release_uri")  if ($verbose > 1);
                }
            }
            else
            {
                $checksums = 0;
            }
        }
        if ( not $checksums )
        {
            if ( $line eq "SHA256:" )
            {
                $checksums = 1;
            }
        }
    }
}

sub process_translation_index
{
    # Extract all translation files from the dists/$DIST/$COMPONENT/i18n/Index
    # file. Fall back to parsing dists/$DIST/Release if i18n/Index is not found.

    my $dist_uri  = remove_double_slashes(shift);
    my $component = shift;
    my ( $base_uri, $index_uri, $index_path, $line ) = '';

    $base_uri   = $dist_uri . $component . "/i18n/";
    $index_uri  = $base_uri . "Index";
    $index_path = get_variable("skel_path") . "/" . sanitise_uri($index_uri);

    unless ( open STREAM, "<$index_path" )
    {
        find_translation_files_in_release( $dist_uri, $component );
        return;
    }

    my $checksums = 0;
    while ( $line = <STREAM> )
    {
        chomp $line;
        if ($checksums)
        {
            if ( $line =~ /^ +(.*)$/ )
            {
                my @parts = split( / +/, $1 );
                if ( @parts == 3 )
                {
                    my ( $sha1, $size, $filename ) = @parts;
                    add_url_to_download( $base_uri . $filename, $size );
                }
                else
                {
                    warn("Malformed checksum line \"$1\" in $index_uri")  if ($verbose > 1);
                }
            }
            else
            {
                $checksums = 0;
            }
        }
        if ( not $checksums )
        {
            if ( $line eq "SHA256:" or $line eq "SHA1:" or $line eq "MD5Sum:" )
            {
                $checksums = 1;
            }
        }
    }

    close STREAM;
}


sub mainsub_process_translation
{
    print "\n Processing translation indexes: ["
        if $progress;

    foreach (@config_binaries)
    {
        my ( $arch, $uri, $distribution, @components ) = @{$_};
        print "T" if $progress;
        # print "T-$distribution " if $progress;
        if (@components)
        {
            $url = $uri . "/dists/" . $distribution . "/";

            my $component;
            foreach $component (@components)
            {
                # print "C-$component " if $progress;
                process_translation_index( $url, $component );
            }
        }
    }

    print "]\n" if $progress;

    # push( @index_urls, sort keys %urls_to_download );
    # download_urls( "translation", sort keys %urls_to_download );

    # foreach ( keys %urls_to_download )
    # {
    #     s[^(\w+)://][];
    #     s[~][%7E]g if get_variable("_tilde");
    #     s[\+][%2B]g if get_variable("_plus");
    #     $skipclean{$_} = 1;
    # }
}

mainsub_process_translation()  if ( get_variable("exec_translation") > 0 );



######################################################################################
## DEP-11 index download


# %urls_to_download = ();

sub find_dep11_files_in_release
{
    # Look in the dists/$DIST/Release file for the DEP-11 files that belong
    # to the given component and architecture.

    my $dist_uri  = shift;
    my $component = shift;
    my $arch      = shift;
    my ( $release_uri, $release_path, $line ) = '';

    $release_uri  = $dist_uri . "Release";
    $release_path = get_variable("skel_path") . "/" . sanitise_uri($release_uri);

    unless ( open STREAM, "<$release_path" )
    {
        warn( "Failed to open Release file from " . $release_uri )  if ($verbose > 1);
        return;
    }

    my $checksums = 0;
    while ( $line = <STREAM> )
    {
        chomp $line;
        if ($checksums)
        {
            if ( $line =~ /^ +(.*)$/ )
            {
                my @parts = split( / +/, $1 );
                if ( @parts == 3 )
                {
                    my ( $sha1, $size, $filename ) = @parts;
                    if ( $filename =~ m{^$component/dep11/(Components-${arch}\.yml|icons-(.*)+\.tar)\.(gz|bz2|xz)$} )
                    {
                        add_url_to_download( $dist_uri . $filename, $size );
                    }
                }
                else
                {
                    warn("Malformed checksum line \"$1\" in $release_uri")  if ($verbose > 1);
                }
            }
            else
            {
                $checksums = 0;
            }
        }
        if ( not $checksums )
        {
            if ( $line eq "SHA256:" )
            {
                $checksums = 1;
            }
        }
    }
}


sub mainsub_process_dep11
{
    print "\n Processing DEP-11 indexes: ["
            if $progress;

    foreach (@config_binaries)
    {
        my ( $arch, $uri, $distribution, @components ) = @{$_};
        print "D" if $progress;
        # print "D-$distribution " if $progress;
        if (@components)
        {
            $url = $uri . "/dists/" . $distribution . "/";

            my $component;
            foreach $component (@components)
            {
                # print "C-$component A-$arch " if $progress;
                find_dep11_files_in_release( $url, $component, $arch );
            }
        }
    }

    print "]\n" if $progress;

    # push( @index_urls, sort keys %urls_to_download );
    # download_urls( "dep11", sort keys %urls_to_download );

    # foreach ( keys %urls_to_download )
    # {
    #     s[^(\w+)://][];
    #     s[~][%7E]g if get_variable("_tilde");
    #     s[\+][%2B]g if get_variable("_plus");
    #     $skipclean{$_} = 1;
    # }
}

mainsub_process_dep11()  if ( get_variable("exec_dep11") > 0 );


######################################################################################
## by-hash SHA256 files download

if ( get_variable("exec_by_hash") > 0 )
{
    # %urls_to_download = ();

    sub find_by_hash_sha256_files_in_release
    {
        # Look in the dists/$DIST/Release file for the by-hash SHA256 files that belong
        # to the given component and architecture.

        my $dist_uri  = shift;
        my $component = shift;
        my $arch      = shift;
        my ( $release_uri, $release_path, $line ) = '';

        $release_uri  = $dist_uri . "Release";
        $release_path = get_variable("skel_path") . "/" . sanitise_uri($release_uri);

        unless ( open STREAM, "<$release_path" )
        {
            warn( "Failed to open Release file from " . $release_uri )  if ($verbose > 1);
            return;
        }

        my $checksums = 0;
        while ( $line = <STREAM> )
        {
            chomp $line;
            if ($checksums)
            {
                if ( $line =~ /^ +(.*)$/ )
                {
                    my @parts = split( / +/, $1 );
                    if ( @parts == 3 )
                    {
                        my ( $sha256, $size, $filename ) = @parts;
                        my $dirname = dirname($filename);
                        my $sha256_filename = '/'.$dirname.'/by-hash/SHA256/'.$sha256;
                        {
                            add_url_to_download( $dist_uri . $sha256_filename, $size );
                        }
                    }
                    else
                    {
                        warn("Malformed checksum line \"$1\" in $release_uri")  if ($verbose > 1);
                    }
                }
                else
                {
                    $checksums = 0;
                }
            }
            if ( not $checksums )
            {
                if ( $line eq "SHA256:" )
                {
                    $checksums = 1;
                }
            }
        }
    }

    print "\n Processing SHA256 by-hash files ["
        if $progress;

    foreach (@config_binaries)
    {
        my ( $arch, $uri, $distribution, @components ) = @{$_};
        print "H" if $progress;
        # print "D-$distribution " if $progress;
        if (@components)
        {
            $url = $uri . "/dists/" . $distribution . "/";

            my $component;
            foreach $component (@components)
            {
                # print "C-$component A-$arch " if $progress;
                find_by_hash_sha256_files_in_release( $url, $component, $arch );
            }
        }
    }

    print "]\n" if $progress;

    # push( @index_urls, sort keys %urls_to_download );
    # download_urls( "by-hash-SHA256", sort keys %urls_to_download );

    # foreach ( keys %urls_to_download )
    # {
    #     s[^(\w+)://][];
    #     s[~][%7E]g if get_variable("_tilde");
    #     s[\+][%2B]g if get_variable("_plus");
    #     $skipclean{$_} = 1;
    # }
}

######################################################################################
## cnf directory download


if ( get_variable("exec_cnf") > 0 )
{

    # %urls_to_download = ();

    sub find_cnf_files_in_release
    {
        # Look in the dists/$DIST/Release file for the cnf files that belong
        # to the given component and architecture.

        my $dist_uri  = shift;
        my $component = shift;
        my $arch      = shift;
        my ( $release_uri, $release_path, $line ) = '';

        $release_uri  = $dist_uri . "Release";
        $release_path = get_variable("skel_path") . "/" . sanitise_uri($release_uri);

        unless ( open STREAM, "<$release_path" )
        {
            warn( "Failed to open Release file from " . $release_uri )  if ($verbose > 1);
            return;
        }

        my $checksums = 0;
        while ( $line = <STREAM> )
        {
            chomp $line;
            if ($checksums)
            {
                if ( $line =~ /^ +(.*)$/ )
                {
                    my @parts = split( / +/, $1 );
                    if ( @parts == 3 )
                    {
                        my ( $sha1, $size, $filename ) = @parts;
                        if ( $filename =~ m{^$component/cnf/(Commands-${arch}(\.(gz|bz2|xz))?)$} )
                        {
                            add_url_to_download( $dist_uri . $filename, $size );
                        }
                    }
                    else
                    {
                        warn("Malformed checksum line \"$1\" in $release_uri")  if ($verbose > 1);
                    }
                }
                else
                {
                    $checksums = 0;
                }
            }
            if ( not $checksums )
            {
                if ( $line eq "SHA256:" )
                {
                    $checksums = 1;
                }
            }
        }
    }

    print "\n Processing cnf indexes: ["
        if $progress;

    foreach (@config_binaries)
    {
        my ( $arch, $uri, $distribution, @components ) = @{$_};
        print "C" if $progress;
        # print "C-$distribution " if $progress;
        if (@components)
        {
            $url = $uri . "/dists/" . $distribution . "/";

            my $component;
            foreach $component (@components)
            {
                # print "C-$component A-$arch " if $progress;
                find_cnf_files_in_release( $url, $component, $arch );
            }
        }
    }

    print "]\n" if $progress;

    # push( @index_urls, sort keys %urls_to_download );
    # download_urls( "cnf", sort keys %urls_to_download );

    # foreach ( keys %urls_to_download )
    # {
    #     s[^(\w+)://][];
    #     s[~][%7E]g if get_variable("_tilde");
    #     s[\+][%2B]g if get_variable("_plus");
    #     $skipclean{$_} = 1;
    # }
}



######################################################################################
## debian-installer directory download


if ( get_variable("exec_deb_ins") > 0 )
{

    # %urls_to_download = ();

    sub find_debian_files_in_release
    {
        # Look in the dists/$DIST/Release file for the debian-installer files that belong
        # to the given component and architecture.

        my $dist_uri  = shift;
        my $component = shift;
        my $arch      = shift;
        my ( $release_uri, $release_path, $line ) = '';

        $release_uri  = $dist_uri . "Release";
        $release_path = get_variable("skel_path") . "/" . sanitise_uri($release_uri);

        unless ( open STREAM, "<$release_path" )
        {
            warn( "Failed to open Release file from " . $release_uri )  if ($verbose > 1);
            return;
        }

        my $checksums = 0;
        while ( $line = <STREAM> )
        {
            chomp $line;
            if ($checksums)
            {
                if ( $line =~ /^ +(.*)$/ )
                {
                    my @parts = split( / +/, $1 );
                    if ( @parts == 3 )
                    {
                        my ( $sha1, $size, $filename ) = @parts;
                        if ( $filename =~ m{^$component/debian-installer/(binary-${arch})/Packages(\.(gz|bz2|xz))?$} )
                        {
                            add_url_to_download( $dist_uri . $filename, $size );
                        }
                    }
                    else
                    {
                        warn("Malformed checksum line \"$1\" in $release_uri")  if ($verbose > 1);
                    }
                }
                else
                {
                    $checksums = 0;
                }
            }
            if ( not $checksums )
            {
                if ( $line eq "SHA256:" )
                {
                    $checksums = 1;
                }
            }
        }
    }

    print "\n Processing debian-installer: ["
        if $progress;

    foreach (@config_binaries)
    {
        my ( $arch, $uri, $distribution, @components ) = @{$_};
        print "E" if $progress;
        # print "D-$distribution " if $progress;
        if (@components)
        {
            $url = $uri . "/dists/" . $distribution . "/";

            my $component;
            foreach $component (@components)
            {
                # print "C-$component A-$arch " if $progress;
                find_debian_files_in_release( $url, $component, $arch );
            }
        }
    }

    print "]\n" if $progress;

    # push( @index_urls, sort keys %urls_to_download );
    # download_urls( "debian-installer", sort keys %urls_to_download );

    # foreach ( keys %urls_to_download )
    # {
    #     s[^(\w+)://][];
    #     s[~][%7E]g if get_variable("_tilde");
    #     s[\+][%2B]g if get_variable("_plus");
    #     $skipclean{$_} = 1;
    # }
}





######################################################################################
## debian-iso process indexes

if ( get_variable("exec_deb_iso") > 0 )
{

    # %urls_to_download = ();
    my %urls_iso = ();

    sub find_file_iso_at_sums
    {
        my ($uri_base, $dir_sums, $file_name) = @_;
        chomp $uri_base;
        chomp $dir_sums;
        chomp $file_name;

        unless ( open STREAM, "<$dir_sums/$file_name" )
        {
            warn( "Failed to open SUMS file from $dir_sums/$file_name" )  if ($verbose > 1);
            return;
        }
        my $checksums = 0;
        my $line = "";
        while ( $line = <STREAM> )
        {
            chomp $line;
			my @parts = split( / +/, $line );
			if ( @parts == 2 )
			{
				my ( $asum, $afile ) = @parts;
				chomp $afile;
				$urls_iso{"$uri_base/$afile"} = $afile;
				# my $size = add_url_to_download( "$uri_base/$afile", 1 );
				# print "\n size=$size $afile ";
			}
        }
    }

    print "\n Processing debian-iso files: ["
        if $progress;

    my $mirror_path = get_variable("mirror_path");
    foreach (@config_isos)
    {
        print "I" if $progress;
        my $uri = $_;
        chomp $uri;

        my $path = $uri;
        $path =~ s[^(\w+)://][];
        $path =~ s[/$][];
        $path = un_sanitise_filename(remove_double_slashes($path));

        find_file_iso_at_sums($uri, "$mirror_path/$path", "SHA256SUMS");
        find_file_iso_at_sums($uri, "$mirror_path/$path", "SHA512SUMS");
    }

	foreach (sort keys %urls_iso) {
		my $url = $_;
		my $size = add_url_to_download( $url, 1 );
		my $afile = $urls_iso{$url};
		print "\n size=$size $afile " if ( $verbose > 1 );
	}

    print "]\n" if $progress;

    # push( @index_urls, sort keys %urls_to_download );
    # download_urls( "debian-iso", sort keys %urls_to_download );

    # foreach ( keys %urls_to_download )
    # {
    #     s[^(\w+)://][];
    #     s[~][%7E]g if get_variable("_tilde");
    #     s[\+][%2B]g if get_variable("_plus");
    #     $skipclean{$_} = 1;
    # }
}





######################################################################################
## Main download preparations


# %urls_to_download = ();
# my %stat_cache = ();


sub _stat
{
    my ($filename) = shift;
    return @{ $stat_cache{$filename} } if exists $stat_cache{$filename};
    my @res = stat($filename);
    $stat_cache{$filename} = \@res;
    return @res;
}

sub clear_stat_cache
{
    %stat_cache = ();
}

sub need_update_by_size
{
    my $filename       = shift;
    my $size_on_server = shift;

    my ( undef, undef, undef, undef, undef, undef, undef, $size ) = _stat($filename);

    return 1 unless ($size);
    return 0 if $size_on_server == $size;
    return 1;
}

sub remove_spaces($)
{
    my $hashref = shift;
    foreach ( keys %{$hashref} )
    {
        while ( substr( $hashref->{$_}, 0, 1 ) eq ' ' )
        {
            substr( $hashref->{$_}, 0, 1 ) = '';
        }
    }
}

sub un_sanitise_filename
{
    my $filename = shift;
    $filename =~ s/\%7E/~/g;
    $filename =~ s/\%7E/~/g;
    $filename =~ s/\%2B/\+/g;
    $filename =~ s/\%2B/\+/g;
    return $filename;
}

sub need_update_by_sum
{
		my ($afile, $asum, $atype) = @_;
		return 1  unless (-e $afile);

		$asum =~ s/^\s+|\s+$//g;
		my $fsum = "";
		$fsum = md5_hex(read_file($afile))  if ( $atype eq 'md5' );
		$fsum = sha1_hex(read_file($afile))  if ( $atype eq 'sha1' );
		$fsum = sha256_hex(read_file($afile))  if ( $atype eq 'sha256' );

		return fc($asum) ne fc($fsum);
}


sub process_index
{

    my $uri   = shift;
    my $index = shift;
    my ( $path, $package, $mirror, $files, $fullpath_filename, $path_index ) = '';

    $path = sanitise_uri($uri);
    local $/ = "\n\n";
    $mirror = get_variable("mirror_path") . "/" . $path;
    $path_index = remove_double_slashes( "$mirror/$index" );  #Bug #1730285 Ubuntu

    unless (-e "$path_index" ) {
        system("gunzip -dfk < $path_index.gz > $path_index")  if (-e "$path_index.gz" );

        # if gunzip failed
        unless (-e "$path_index" ) {
            system("xz -dfk < $path_index.xz > $path_index")  if (-e "$path_index.xz" );
        }

        # if xz decompress failed
        unless (-e "$path_index" ) {
            system("bzip2 -dfk < $path_index.bz2 > $path_index")  if (-e "$path_index.bz2" );
        }
    }

    unless ( open STREAM, "<$path_index" )
    {
        warn("apt-mirror: can't open index $path_index in process_index")  if ($verbose > 1);
        return;
    }

    while ( $package = <STREAM> )
    {
        local $/ = "\n";
        chomp $package;
        my ( undef, %lines ) = split( /^([\w\-]+:)/m, $package );

        $lines{"Directory:"} = "" unless defined $lines{"Directory:"};
        chomp(%lines);
        remove_spaces( \%lines );

        if ( exists $lines{"Filename:"} )
        {    # Packages index
						$fullpath_filename = un_sanitise_filename(remove_double_slashes( $mirror . "/" . $lines{"Filename:"} ));
            $skipclean{ $fullpath_filename } = 1;

            print FILES_ALL $fullpath_filename . "\n";
            print "ALL: " . $fullpath_filename . "\n"
                if $verbose >= 3;


            # check if need to update
            my $need_update = 0;

            # check file size
            $need_update = need_update_by_size( $fullpath_filename, $lines{"Size:"} );

            # check file sum
            if (-e $fullpath_filename && $need_update < 1 && get_variable("pre_check_sum") > 0 )
            {
                # $need_update = need_update_by_sum($fullpath_filename, $lines{"MD5sum:"}, "md5") if defined $lines{"MD5sum:"};
                # $need_update = need_update_by_sum($fullpath_filename, $lines{"SHA1:"}, "sha1") if defined $lines{"SHA1:"};
                # $need_update = need_update_by_sum($fullpath_filename, $lines{"SHA256:"}, "sha256") if defined $lines{"SHA256:"};
            }

            if ( $need_update > 0 )
            {
                print FILES_NEW remove_double_slashes( $uri . "/" . $lines{"Filename:"} ) . "\n";
                print "NEW: " . remove_double_slashes( $uri . "/" . $lines{"Filename:"} ) . "\n"
                    if $verbose >= 1;

                print FILES_MD5 $lines{"MD5sum:"} . "  " . $fullpath_filename . "\n" if defined $lines{"MD5sum:"};
                print FILES_SHA1 $lines{"SHA1:"} . "  " . $fullpath_filename . "\n" if defined $lines{"SHA1:"};
                print FILES_SHA256 $lines{"SHA256:"} . "  " . $fullpath_filename . "\n" if defined $lines{"SHA256:"};

                add_url_to_download( $uri . "/" . $lines{"Filename:"}, $lines{"Size:"} );
                push( @del_files, $fullpath_filename )  if (-e $fullpath_filename && get_variable("delete_bad_file") > 0 );
            }
        }
        elsif ( exists $lines{"Files:"} )
        {    # Sources index
            foreach ( split( /\n/, $lines{"Files:"} ) )
            {
                next if $_ eq '';
                my @file = split;
                die("apt-mirror: invalid Sources format") if @file != 3;

                $fullpath_filename = un_sanitise_filename(remove_double_slashes( $mirror . "/" . $lines{"Directory:"} . "/" . $file[2] ) );
                $skipclean{ $fullpath_filename  } = 1;

                print FILES_ALL $fullpath_filename . "\n";
                print "ALL: " . $fullpath_filename . "\n"
                    if $verbose >= 3;


                # check if need to update
                my $need_update = 0;

                # check file size
                $need_update = need_update_by_size( $fullpath_filename, $file[1] );

                # check file sum
                if (-e $fullpath_filename && $need_update < 1 && get_variable("pre_check_sum") > 0 )
                {
                        # $need_update = need_update_by_sum($fullpath_filename, $file[0], "md5");
                }

                if ( $need_update > 0 )
                {
                    print FILES_NEW remove_double_slashes( $uri . "/" . $lines{"Directory:"} . "/" . $file[2] ) . "\n";
                    print "NEW: " . remove_double_slashes( $uri . "/" . $lines{"Directory:"} . "/" . $file[2] ) . "\n"
                        if $verbose >= 1;

                    print FILES_MD5 $file[0] . "  " . $fullpath_filename . "\n";

                    add_url_to_download( $uri . "/" . $lines{"Directory:"} . "/" . $file[2], $file[1] );
                    push( @del_files, $fullpath_filename )  if (-e $fullpath_filename && get_variable("delete_bad_file") > 0 );
                }
            }
        }
    }

    close STREAM;
}


sub mainsub_process_indexes
{
    open FILES_ALL, ">" . get_variable("var_path") . "/ALL" or die("apt-mirror: can't write to intermediate file (ALL)");
    open FILES_NEW, ">" . get_variable("var_path") . "/NEW" or die("apt-mirror: can't write to intermediate file (NEW)");
    open FILES_MD5, ">" . get_variable("var_path") . "/MD5" or die("apt-mirror: can't write to intermediate file (MD5)");
    open FILES_SHA1, ">" . get_variable("var_path") . "/SHA1" or die("apt-mirror: can't write to intermediate file (SHA1)");
    open FILES_SHA256, ">" . get_variable("var_path") . "/SHA256" or die("apt-mirror: can't write to intermediate file (SHA256)");

    print "\n Processing indexes: {S=source, B=Binary} ["
        if $progress;

    foreach (@config_sources)
    {
        my ( $uri, $distribution, @components ) = @{$_};
        print "S" if $progress;
        # print "S-$distribution " if $progress;
        if (@components)
        {
            my $component;
            foreach $component (@components)
            {
                # print "C-$component " if $progress;
                process_index( $uri, "/dists/$distribution/$component/source/Sources" );
            }
        }
        else
        {
            process_index( $uri, "/$distribution/Sources" );
        }
    }

    print "  " if $progress;
    foreach (@config_binaries)
    {
        my ( $arch, $uri, $distribution, @components ) = @{$_};
        print "B" if $progress;
        # print "P-$distribution " if $progress;
        if (@components)
        {
            my $component;
            foreach $component (@components)
            {
                # print "C-$component A-$arch " if $progress;
                process_index( $uri, "/dists/$distribution/$component/binary-$arch/Packages" );
            }
        }
        elsif ($distribution)
        {
            process_index( $uri, "/$distribution/Packages" );
        }
        else
        {
            process_index( $uri, "/Packages" );
        }
    }

    clear_stat_cache();
    print "]\n" if $progress;

    if ( scalar @del_files )
    {
        print "\n --- Delete file with mismatch size: " . scalar @del_files . " files"  if $progress;
        unlink( @del_files );
        @del_files = ();
    }
    else
    {
        print "\n No file with mismatch size found. "  if $progress;
    }

    close FILES_ALL;
    close FILES_NEW;
    close FILES_MD5;
    close FILES_SHA1;
    close FILES_SHA256;
}


sub checksum_checking
{
    my ( $ajob ) = @_;
    $ajob = lc($ajob);

    my $ajob_str = "";
    $ajob_str = "Pre-Mirroring"  if ( $ajob eq "pre" );
    $ajob_str = "Post-Mirroring"  if ( $ajob eq "post" );
    print "\n\n\n Checksum Checking: $ajob_str "  if $progress;

    my $var_path = get_variable("var_path");
    my $checksum_fails = 0;

    my $input_file_md5 = "$var_path/MD5";
    my $input_file_sha1 = "$var_path/SHA1";
    my $input_file_sha256 = "$var_path/SHA256";

    $checksum_fails += checking_file_sum($ajob, "md5", $input_file_md5);
    $checksum_fails += checking_file_sum($ajob, "sha1", $input_file_sha1);
    $checksum_fails += checking_file_sum($ajob, "sha256", $input_file_sha256);
	print "\n\n"  if $progress;

	return $checksum_fails;
}

mainsub_process_indexes();
checksum_checking('Pre')  if ( get_variable("pre_check_sum") > 0 );




######################################################################################
## Main download


sub mainsub_main_download
{
    print "\n\n Main download.. "  if $progress;

    chdir get_variable("mirror_path") or die("apt-mirror: can't chdir to mirror");

    my $need_bytes = 0;
    foreach ( values %urls_to_download )
    {
        $need_bytes += $_;
    }

    my $size_output = format_bytes($need_bytes);
    my $url_count = scalar(%urls_to_download);

    if ( get_variable("dry_run") > 0 )
    {
        print "\n\n $size_output will be downloaded into archive [$url_count urls].\n";
        print " A dry-run was requested, no download performed, exiting.\n";
        unlock_aptmirror();
        exit(0)
    }

    (my $size_mirror) = $size_output =~ /\A([^:\s]+)/;
    my $directory = get_variable("mirror_path");
    my $command = "df $directory | awk -F'[^0-9]*' 'NR==2 {print \$5}'";
    (my $directory_size) = format_bytes(`$command`*1000) =~ /\A([^:\s]+)/;

    if ($directory_size <= $size_mirror) {
        warn("apt-mirror: need space $size_output\n")  if ($verbose > 1);
    }
    else
    {
        print " $size_output will be downloaded into archive [$url_count urls].\n";

        download_urls( "archive", sort keys %urls_to_download );

        ######################################################################################
        ## Copy skel to main archive

        sub copy_file
        {
            my ( $from, $to ) = @_;
            my $dir = dirname($to);
            return unless -f $from;
            make_path($dir) unless -d $dir;
            if ( get_variable("unlink") == 1 )
            {
                if ( compare( $from, $to ) != 0 ) { unlink($to); }
            }
            unless ( copy( $from, $to ) )
            {
                warn("apt-mirror: can't copy $from to $to")  if ($verbose > 1);
                return;
            }
            my ( $atime, $mtime ) = ( stat($from) )[ 8, 9 ];
            utime( $atime, $mtime, $to ) or die("apt-mirror: can't utime $to");
        }

        foreach (@index_urls)
        {
            die("apt-mirror: invalid url in index_urls: $_") unless s[^(\w+)://][];
            copy_file( get_variable("skel_path") . "/" . sanitise_uri("$_"), get_variable("mirror_path") . "/" . sanitise_uri("$_") );
            copy_file( get_variable("skel_path") . "/" . sanitise_uri("$_"), get_variable("mirror_path") . "/" . sanitise_uri("$_") ) if (s/\.gz$//);
            copy_file( get_variable("skel_path") . "/" . sanitise_uri("$_"), get_variable("mirror_path") . "/" . sanitise_uri("$_") ) if (s/\.bz2$//);
            copy_file( get_variable("skel_path") . "/" . sanitise_uri("$_"), get_variable("mirror_path") . "/" . sanitise_uri("$_") ) if (s/\.xz$//);
        }
    }
}

mainsub_main_download();

my $post_fails = 0;
$post_fails = checksum_checking('Post')  if ( get_variable("post_check_sum") > 0 );



######################################################################################
## Make cleaning script


if ( get_variable("exec_clean") > 0 && $post_fails < 1 )
{

    print "\n\n Create clean script.. "  if $progress;

    my ( @rm_dirs, @rm_files ) = ();
    my $unnecessary_bytes = 0;

    sub process_symlink
    {
        return 1;    # symlinks are always needed
    }

    sub process_file
    {
        my $file = shift;
        $file =~ s[~][%7E]g if get_variable("_tilde");
        $file =~ s[\+][%2B]g if get_variable("_plus");
        return 1 if $skipclean{$file};

        push @rm_files, sanitise_uri($file);
        my ( undef, undef, undef, undef, undef, undef, undef, $size, undef, undef, undef, undef, $blocks ) = stat($file);
        $unnecessary_bytes += $blocks * 512  if (defined $blocks);
        return 0;
    }

    sub process_directory
    {
        my $dir       = shift;
        my $is_needed = 0;
        return 1 if $skipclean{$dir};
        opendir( my $dir_h, $dir ) or die "apt-mirror: can't opendir $dir: $!";
        foreach ( grep { !/^\.$/ && !/^\.\.$/ } readdir($dir_h) )
        {
            my $item = $dir . "/" . $_;
            $is_needed |= process_directory($item) if -d $item && !-l $item;
            $is_needed |= process_file($item)      if -f $item;
            $is_needed |= process_symlink($item)   if -l $item;
        }
        closedir $dir_h;
        push @rm_dirs, $dir unless $is_needed;
        return $is_needed;
    }

    chdir get_variable("mirror_path") or die("apt-mirror: can't chdir to mirror");

    foreach ( keys %clean_directory )
    {
        process_directory($_) if -d $_ && !-l $_;
    }

    open CLEAN, ">" . get_variable("cleanscript") or die("apt-mirror: can't open clean script file");

    my ( $i, $total ) = ( 0, scalar @rm_files );

    if ( get_variable("_autoclean") )
    {

        my $size_output = format_bytes($unnecessary_bytes);
        print "$size_output in $total files and " . scalar(@rm_dirs) . " directories will be freed...";

        chdir get_variable("mirror_path") or die("apt-mirror: can't chdir to mirror");

        foreach (@rm_files) { unlink $_; }
        foreach (@rm_dirs)  { rmdir $_; }

    }
    else
    {

        my $size_output = format_bytes($unnecessary_bytes);
        print "$size_output in $total files and " . scalar(@rm_dirs) . " directories can be freed.\n";
        print "Run " . get_variable("cleanscript") . " for this purpose.\n\n";

        print CLEAN "#!/bin/sh\n";
        print CLEAN "set -e\n\n";
        print CLEAN "cd " . quoted_path(get_variable("mirror_path")) . "\n\n";
        print CLEAN "echo 'Removing $total unnecessary files [$size_output]...'\n";
        foreach (@rm_files)
        {
            print CLEAN "rm -f '$_'\n";
            print "  $_\n" if $verbose >= 1;
            print CLEAN "echo -n '[" . int( 100 * $i / $total ) . "\%]'\n" unless $i % 500;
            print CLEAN "echo -n .\n" unless $i % 10;
            $i++;
        }
        print CLEAN "echo 'done.'\n";
        print CLEAN "echo\n\n";

        $i     = 0;
        $total = scalar @rm_dirs;
        print CLEAN "echo 'Removing $total unnecessary directories...'\n";
        foreach (@rm_dirs)
        {
            print CLEAN "if test -d '$_'; then rm -rf '$_'; fi\n";
            print CLEAN "echo -n '[" . int( 100 * $i / $total ) . "\%]'\n" unless $i % 50;
            print CLEAN "echo -n .\n";
            $i++;
        }
        print CLEAN "echo 'done.'\n";
        print CLEAN "echo\n";

        close CLEAN;

    }

    # Make clean script executable
    print "\n\n Execute clean script.. "  if $progress;

    my $perm = ( stat get_variable("cleanscript") )[2] & 07777;
    chmod( $perm | 0111, get_variable("cleanscript") );

    if ( get_variable("run_postmirror") )
    {
        print "Running the Post Mirror script ...\n";
        print "(" . get_variable("postmirror_script") . ")\n\n";
        if (-e get_variable("postmirror_script") )
		{
			if (-x get_variable("postmirror_script") )
			{
				system(get_variable("postmirror_script").'');
			}
			else
			{
				system('/bin/sh', get_variable("postmirror_script"));
			}
			print "\nPost Mirror script has completed. See above output for any possible errors.\n\n";
		}
		else {
			print "--- Post Mirror script not exists.";
		}
    }
}

unlock_aptmirror();
